{
  "hash": "29ee0a78a3b25379ba5bedcb10d929ae",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    pagetitle: \"Area Data II\"\n    menu: false\n    footer: \"2025 Zehui Yin\"\n---\n\n\n\n## Spatial autocorrelation\n\n> Everything is related to everything else, but near things are more related than distant things.\n>\n> ---Tobler, W. R.\n\n![](./images/arealdata-SAC-1.png){width=330px}\n![](./images/arealdata-SAC-2.png){width=330px}\n![](./images/arealdata-SAC-3.png){width=330px}\n\n## Global Moran's $I$\n\n$$\nI = \\frac{n \\sum_i \\sum_j w_{ij}(Y_i - \\overline Y)(Y_j - \\overline Y)}\n{(\\sum_{i \\neq j} w_{ij}) \\sum_i (Y_i - \\overline Y)^2}\n$$\n\nWhen we use a row-standardized spatial weight matrix, $W^{st}$, and denote $z_i \\equiv (Y_i-\\overline{Y})$:\n\n$$\nI = \\frac{\\sum_{i=1}^n{z_i\\sum_{j=1}^n{w_{ij}^{st}z_j}}}{\\sum_{i=1}^{n}{z_i^2}}\n$$\n\n## Global Moran's $I$ interpretation\n\n- Moran’s $I$ values usually range from –1 to 1.\n- Values significantly above the expected value indicate positive spatial autocorrelation or clustering.\n- Values significantly below the expected value indicate negative spatial autocorrelation or dispersion.\n\n## Local Moran's $I$\n\n:::{style=\"font-size: 0.9em;\"}\n$$\nI_i = \\frac{n (Y_i - \\overline Y)}{\\sum_j (Y_j - \\overline Y)^2} \\sum_j w_{ij}(Y_j - e Y)\n$$\n\nNoting that\n\n$$\nI = \\frac{1}{\\sum_{i \\neq j} w_{ij}}\\sum_i I_i\n$$\n\nWhen we use a row-standardized spatial weight matrix, $W^{st}$, we have $I = \\frac{\\sum_i I_i}{n} = \\overline{I_i}$.\n:::\n\n## Multiple testing\n\n:::{style=\"font-size: 0.9em;\"}\nThe $\\alpha$ in hypothesis testing is the probability of making a type I error (false positive).\n\nIn our context, it means concluding that a truly random spatial pattern is non-random, thus rejecting the null hypothesis.\n\nWhen running multiple tests simultaneously using overlapping information, we are more likely to encounter these types of errors purely due to chance.\n\nTherefore, we must adjust $p$-values (downward) to ensure that we maintain the desired $\\alpha$ level.\n\nOne way to do this is Bonferroni correction: $\\alpha_{adjusted}=\\frac{\\alpha}{m}$, where $m$ is the number of simultaneous tests.\n:::\n\n## `plotly` package\n\n:::{style=\"font-size: 0.9em;\"}\nThe `plotly` package in R is a binding to the open-source JavaScript graphing library, `plotly.js`. It excels at creating interactive web graphics, including maps and figures.\n\nHowever, it does **not** support knitting the `Rmd` file into a PDF since PDFs are static files, unlike HTML outputs.\n\nTo include `plotly` graphics in a knitted PDF, take a screenshot of the output and insert the screenshot as a static image in the PDF file:\n:::\n\n:::{style=\"font-size: 1.2em;\"}\n\n\n\n````{.default}\n```{r, eval=FALSE}\nSome R codes that you do not want to evaluate during knitting.\n```\n![](path-to-image)\n````\n\n\n:::\n\n## Functions in R recap\n\nFunctions in R use the following syntax. Note that any thing wrapped in `<...>` indicates that it is just a name and can be called anything you like.\n\n\n\n\n````{.default}\n```{r}\n<function_name> <- function(<parameter1>, <parameter2>) { \n  Some R codes to execute based on the inputs\n  and at last return an output\n}\n\nfunction_name(<object1>, \n              parameter2 = <object2>)\n```\n````\n\n\n\nYou only need to define functions once in your code. Then, you can call it by its name.\n\n## Activities for today\n\n- We will work on the following chapter from the textbook:\n  - Chapter [24](https://paezha.github.io/spatial-analysis-r/activity-11-area-data-iii.html): Activity 11: Area Data III\n  - Chapter [26](https://paezha.github.io/spatial-analysis-r/activity-12-area-data-iv.html): Activity 12: Area Data IV\n- The hard deadline is **Friday**, **March 7**.\n\n## Reference\n\n- <https://www.paulamoraga.com/book-spatial/spatial-autocorrelation.html>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}
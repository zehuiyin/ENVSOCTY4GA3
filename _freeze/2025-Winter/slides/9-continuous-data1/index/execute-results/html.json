{
  "hash": "38263ba38bce88e73825e46e08088cee",
  "result": {
    "engine": "knitr",
    "markdown": "---\nformat: \n  revealjs:\n    pagetitle: \"Spatially Continuous Data I\"\n    menu: false\n    footer: \"2025 Zehui Yin\"\n---\n\n\n\n## Spatially continuous data\n\n- Previously, we explored point data and area data, which are associated with discrete events, such as store locations or individual residents.\n- In contrast, spatial phenomena can be continuous rather than discrete.\n- Examples of continuous phenomena include elevation and temperature.\n- Continuous data are typically stored in raster formats but can also be represented as vector points.\n\n## Spatially continuous data\n\n:::{style=\"text-align:center;\"}\n\n\n::: {.cell}\n\n:::\n\n\n![](./images/point1.png){width=500px}\n:::\n\n:::{style=\"font-size: 0.8em;\"}\n- Here, each point represents a measurement of the underlying continuous process, rather than a discrete event.\n- The methods weâ€™ll discuss this week are specific to continuous data and are not suitable for point pattern analysis, and vice versa.\n:::\n\n## Motivation for spatial interpolation\n\n:::: {.columns}\n\n::: {.column width=\"60%\"}\n\n\n\n::: {.cell}\n\n:::\n\n\n![](./images/point2.png)\n:::\n\n::: {.column width=\"40%\"}\n:::{style=\"font-size: 0.7em;\"}\n- Since it is impossible to observe an entire continuous process, there are infinitely many points that remain unobserved.\n- To understand the process at a specific, unknown location, we aim to estimate its value based on available data.\n- Spatial interpolation techniques address this challenge by providing methods to predict values at these unmeasured points.\n:::\n:::\n\n::::\n\n## Spatial interpolation\n\n:::{style=\"font-size: 0.8em;\"}\n\n**Voronoi Polygons/Tessellation**:\n\n- Predict the value of an unknown point by assigning it the value of the nearest known point.\n\n**Inverse distance weighting (IDW)**: $\\hat{z_p}=\\frac{\\sum_i\\frac{z_i}{d_{pi}^\\gamma}}{\\sum_i\\frac{1}{d_{pi}^\\gamma}}$\n\n- Here, $d_{pi}$ represents the (Euclidean) distance between the unknown point $p$ and a known point $i$.\n\n**$k$-Point Means/$k$-Nearest Neighbours**:\n\n- Predict the value of an unknown point using the average value of the $k$-nearest known points.\n\n:::\n\n## Point estimate and uncertainty\n\n:::{style=\"text-align:center;\"}\n![](./images/estimate.png){width=500px}\n:::\n\n:::{style=\"font-size: 0.9em;\"}\nThe theoretical spatial continuous process: $z_i = f(u_i, v_i) + \\epsilon_i$\n\nWhere $\\hat{f}(u_i, v_i)$ represents the point estimate for location $i$.\n\nUncertainty is the interval that is likely to capture the true value, $z_i$.\n:::\n\n## Accuracy and precision\n\n:::{style=\"text-align:center;\"}\n![](./images/Precision-and-Accuracy-Thompson.jpg){width=550px}\n:::\n\n## Activities for today\n\n- We will work on the following chapter from the textbook:\n  - Chapter [32](https://paezha.github.io/spatial-analysis-r/activity-15-spatially-continuous-data-i.html): Activity 15: Spatially Continuous Data I\n  - Chapter [34](https://paezha.github.io/spatial-analysis-r/activity-16-spatially-continuous-data-ii.html): Activity 16: Spatially Continuous Data II\n- The hard deadline is **Friday**, **March 21**.\n\n## Reference\n\n- <https://blogs.extension.msstate.edu/theriskproject/accuracy-and-precision/>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}